import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
import { faker } from '@faker-js/faker';

// TODO: clean after development done
// DEV ONLY !!
// this will add delay of duration in miliseconds
// just for testing
const pause = (duration) => {
    return new Promise((resolve) => {
        setTimeout(resolve, duration);
    });
};

const albumsApi = createApi({
    reducerPath: 'albums',
    // this will gives us the preconfigured fetch
    baseQuery: fetchBaseQuery({
        baseUrl: 'http://localhost:3005',
        // thhis adds for every request issues a dely of 1000ms
        // just for testing DEV
        // TODO: clean after development done
        fetchFn: async (...args) => { 
            await pause(1000);
            return fetch(...args);
        }
    }),
    endpoints(builder){
        return {
            // deleting request
            // autogenerated hook useRemoveAlbumMutation
            removeAlbum: builder.mutation({
                // now every time we make the mutations it will look for the tags Albums and update them
                // this will be generated on the fly
                // if our tag matches with one of the tags in providede tags, it will invalidete the whole data
                // and fetch it again
                invalidatesTags: (result, error, album) => {
                    return [{type: 'Album', id: album.id}];
                }, 
                query: (album) => {
                    return {
                        url: `/albums/${album.id}`,
                        method: 'DELETE'
                    };
                },
            }),
            // the automaticly generated hook will have the name:
            // useAddAlbumMutation
            addAlbum: builder.mutation({
                // now every time we make the mutations it will look for the tags Albums and update them
                // this will be generated on the fly
                // if our tag matches with one of the tags in providede tags, it will invalidete the whole data
                // and fetch it again
                invalidatesTags: (result, error, user) => {
                    return [{type: 'UsersAlbums', id: user.id}];
                }, 
                query: (user) => {
                    return {
                        url: '/albums',
                        method: 'POST',
                        body: {
                            userId: user.id,
                            title: faker.commerce.productName()
                        }
                    };
                }
            }),
            // bc we created this name we can use a hook like so
            // albumsApi.useFetchAlbumsQuery
            fetchAlbums: builder.query({
                // this string can be anything - this is the tag taht is invalidated by addAlbum, so after mutations
                // the tag will be dynamiclly generated so it can be more specifi
                // if one of the tags get invalidates, the whoel data can get rerendered
                providesTags: (result, error, user) => {
                    // result - data fetch from the server - so albums
                    const tags = result.map(album=>{
                        return {type: 'Album', id: album.id}
                    });
                    tags.push({type: 'UsersAlbums', id: user.id});
                    return tags;
                }, 
                query: (user)=> {
                    return {
                        url: '/albums',
                        params: {
                            userId: user.id
                        },
                        method: 'GET',
                    };
                }
            })
        };
    },

});

export const { 
    useFetchAlbumsQuery, useAddAlbumMutation, useRemoveAlbumMutation
} = albumsApi;
export { albumsApi };